<h4>Algorithms</h4>
<div class="notes 20160106">
    <h5>January 6, 2016</h5>
    <div>
        <i>Why are algorithms important? Why study algorithms?</i>
        <ul class="numbers">
            <li>Pre-requisite</li>
            <li>Abstraction</li>
            <li>Efficacy (ability to produce desired result)</li>
            <li>Efficiency</li>
            <li>Optimization</li>
        </ul>
    </div>
    <div>
        <em>Question: How would you determine if there is a duplicate item in an array?</em>
        <div class="definition">
            <b>Trivial solution:</b>
            <div>For each element, look for another element equal to this one</div>
        </div>
        <div class="nospace b2">\(O(n^2)\)</div>
        <div class="code">
            Input = A size n
            for i = 1...n
                for j = i+1...n
                    if A[i] == A[j]
                        return yes
            return no</div>
        <div class="definition">
            <b>Better:</b>
            <div>Using a hashtable</div>
        </div>
        <div class="nospace b2">\(O(n)\)</div>
        <div class="code">
            let H be a hash table
            for i = 1...n
                if H.contains(A[i])
                    return yes
                else H.add(A[i])
            return no</div>
        <div class="definition">
            <b>Another solution:</b>
            <div>Sort the array first and then find a duplicate element</div>
        </div>
        <div class="nospace b2">\(O(nlogn) + O(n) = O(nlogn)\)</div>
        <div class="code">
            Sort(A)
            for i = 1...n
                if A[i] == A[i+1]
                    return yes
            return no</div>
        <div class="divider"></div>
    </div>
    <div>
        <i>We are concerned with:</i>
        <ul>
            <li>average vs. worst-case complexity</li>
            <li>RAM model</li>
            <li>word-RAM</li>
        </ul>
        <b>For this course, we are most concerned with worst-case complexity</b>
    </div>
    <div>
        <i>Recall asymptotic notations:</i> <br>
        \(g(n) = O(f(n)) \leftrightarrow \lim_{n\to\infty} \frac{g(n)}{f(n)} \leq c\) <br>
        \(g(n) = o(f(n)) \leftrightarrow \lim_{n\to\infty} \frac{g(n)}{f(n)} = 0\) <br>
        \(g(n) = \Theta(f(n) \leftrightarrow g(n) = O(f(n))\) & \(f(n) = O(g(n))\)
    </div>
    <div>
        <i>Algorithm Analysis - correctness & complexity <br>
        Algorithm development</i>
        <ul>
            <li>Reduction</li>
            <li>Recursion</li>
            <li>Divide-and-conquer</li>
            <li>Greedy</li>
            <li>Dynamic programming</li>
        </ul>
    </div>
    <div>
        <i>Topics we will study in this course:</i> <br>
        <ul>
            <li>Intractability</li>
            <li>Polynomial - time reduction</li>
            <li>Undecidability</li>
        </ul>
    </div>
    <div>
        <em>Question: Given an array, find the min and max element</em>
        <div class="definition">
            <b>Trivial solution:</b>
            <div>Go through each element and compare for the max and min</div>
        </div>
        <div class="nospace b2">Worst case is 2n comparisons</div>
        <div class="code">
            min <- A[1], max <- A{i]
            for i = 2...n
                if A[i] > max then max \(\leftarrow\) A[i]
                else if A[i] < min then min \(\leftarrow\) A[i]</div>
        <div class="definition">
            <b>Better:</b>
            <div>Split array into pairs and then compare each pair, separating the lower to a "small" array and bigger to a "big" array.
                Then find the min in "small" array, and the max in "big" array
            </div>
        </div>
        <div class="nospace b2">Worst case \(\frac{1}{2}n + \frac{1}{2}n + \frac{1}{2}n = \frac{3}{2}n\) comparisons</div>
        <div class="divider"></div>
    </div>
</div>
<div class="notes 20160108">
    <h5>January 8, 2016</h5>
    <div>
        <em>Find two elements in an array that sum to m</em>
        <div class="definition">
            <b>Trivial Solution:</b>
            <div>For each element, go through all elements searching for a match</div>
        </div>
        <div class="nospace b2">\(O(n^2)\)</div>
        <div class="code">
            Input: A, m.
            for i = 1...n
                for j = i...n
                    if A[i] + A[j] = m
                        return yes
            return no
        </div>
        <div class="definition">
            <b>Better:</b>
            <div>Sort it and use binary search on second element</div>
        </div>
        <div class="nospace b2">\(O(nlogn)\)</div>
        <div class="code">
            Sort(A)
            for i = 1...n
                binary-search(m - A[i])
                if succeed return yes
            return no
        </div>
        <div class="definition">
            <b>Even Better:</b>
            <div>Use a hashtable</div>
        </div>
        <div class="nospace b2">\(O(n)\)</div>
        <div class="code">
            put A in hashtable H
            for i = 1...n
                if H.contains(m-A[i])
                    return yes
            return no
        </div>
        <div class="divider"></div>
    </div>
    <div>
        <em>Question: How would you extend this problem to 3 elements to add up to m?</em>
        <div class="definition">
            <b>Trivial Solution:</b>
            <div>Go through each element and then use trivial solution of 2 element case</div>
        </div>
        <div class="nospace b2">\(O(n^3)\)</div>
        <div class="definition">
            <b>Better:</b>
            <div>Go through each element and use the better solution of 2 element case</div>
        </div>
        <div class="nospace b2">\(O(n^2logn)\)</div>
        <div class="code">
            for i = 1...n
                if (Two-Sum(A, m-A[i]))
                    return yes
            return no
        </div>
        <div class="divider"></div>
    </div>
    <div>
        <em>Sorted 2 sum case</em>
        <div class="code">
            while (j > i) {
                if (A[i] + A[j] > m)
                    j--;
                else if (A[i] + A[j] < m)
                    i++;
                else
                    return yes
            }
            return no
        </div>
        <div>
            Proof of correctness: <br>
            If array has A[i'] + A[j'] == m <br>
            Time: j-i is n-1 initially <br>
            Each time while loop is repeated, j-i is reduced by 1, so the max will be n-1 loops <br>
            w.t.o.g. Assume i becomes i' when j > j' during the algorithm.
            The other case can be proved by symmetry <br>
            Because A is sorted <br>
            A[i] + A[j] > m <br>
            So j will be reduced constantly until j == j' <span class="qed"></span>
        </div>
    </div>
    <div>
        <em>Back to 3 sum knowing this sorted 2 sum algorithm</em>
        <div class="code">
            Sort(A)                             //\(O(nlogn)\)
            for i = 0...n                       //\(O(n^2))\)
                if (Sorted-2-Sum(A, m-A[i]))
                    return yes
            return no
        </div>
        <div class="divider"></div>
    </div>
    <div>
        <i>Idea of algorithm design:</i>
        <ul>
            <li>reduction</li>
            <li>data structure</li>
            <li>avoid repeated computation</li>
            <li>hot spot</li>
        </ul>
    </div>
    <div>
        <i>Divide-and-conquer</i>
        <div>
            Divide problem into smaller, simpler problems of the same kind <br>
            Eg. merge-sort <br>
            <div class="code">
                merge-sort(A)
                    if |A| < 3 sort A trivially, return
                    mergesort(A[0...n/2])
                    mergesort(A[n/2+1...n])
                merge(A[1...n/2], A[n/2+1...n])
            </div>
            \(T(n) = 2T(\frac{n}{2}) + O(n)\) <br>
            unrolling the recurrence relation <br>
            \(T(n) = 2T(\frac{n}{2}) + n\) <br>
            \(= 2(2T(\frac{n}{4}) + n/2) + n\) <br>
            \(= 4T(\frac{n}{4}) + n + n\) <br>
            \(= 4(2T(\frac{n}{8}) + n/4) + n + n\) <br>
            \(= 8T(\frac{n}{8}) + n + n + n\) <br>
            \(= 2^kT(\frac{n}{2^k}) + n + ... + n\) (k times)
        </div>
    </div>
    <div>
        <i>Guess and check (verify)</i>
        <div>
            Lemma: \(T(n) \leq cnlogn\) <br>
            Proof: Mathematical Induction <br>
            Lemma is correct for n < 3 (vacuously true) <br>
            Assume Lemma correct for n < m <br>
            To prove Lemma for n = m <br>
            \(T(m) = 2T(\frac{m}{2}) + m\) <br>
            \(\leq 2(c\frac{m}{2}log\frac{m}{2}) + m\) <br>
            \(= cm(log_2m - 1) + m\) <br>
            \(= cmlog_2m - (c-1)m\) <br>
            \(\leq cmlog_2m\) <span class="qed"></span> <br>
            <br>
            \(T(n) = 2T(\frac{n}{2}) + n <br>
            <err>Mistake:</err><br>
            \(T(n) = O(n)\) <br>
            Assume correctness for n < m <br>
            \(T(m) = 2T(\frac{m}{2}) + m\) <br>
            \(= 2O(\frac{m}{2}) + O(m)\) <br>
            \(=O(m)\) <br>
            What went wrong? <br>
            Every time we get an O(m), we introduce another constant, so because it is induction,
            we cannot simplify it like this. <br>
            <br>
            \(T(n) \leq 2T(\frac{n}{2} + \sqrt{n}\) <br>
            \(\rightarrow T(n) = O(n)\) <br>
            Lemma: \(T(n) \leq cn\) <br>
            Proof: Assume correctness for n < m <br>
            \(T(m) = 2T(\frac{m}{2}) + \sqrt{m}\) <br>
            \(\leq 2(c\frac{m}{2}) + \sqrt{m}\) <br>
            \(= cm + \sqrt{m}\) <br>
            Lemma: \(T(n) = cn - 3\sqrt{n}\) <br>
        </div>
    </div>
</div>
<div class="notes 20160113">
    <div>
        Modify the induction conclusion
        <div>
            \(T(n) \leq 2T(\frac{n}{2}) + \sqrt {n}\) <br>
            Guess \(T(n) \leq cn\) <br>
            \(T(n) \leq 2T(\frac{n}{2} + \sqrt {n})\) <br>
            \(\leq 2c\frac{n}{2} + \sqrt {n}\) <br>
            \(= cn + \sqrt {n}\) <br>

            Lemma: \(T(n) \leq cn - 3\sqrt{n}\) <br>
            Proof: Omit base case <br>
            \(T(n) \leq 2T(n/2) + \sqrt{n}\) <br>
            \(\leq 2(cn/2 - 3\sqrt {n/2})\) <br>
            \(= cn - 3\sqrt{2}\sqrt{n} + \sqrt{n\)<br>
            \(\leq cn - 3\sqrt {n}\)
        </div>
    </div>
    <div>
        Variable Substitution
        <div>
            \(T(n) = 2T(\sqrt{n}) + log_2n\) <br>
            \(m = logn\) <br>
            \(S(m) = T(2^m) = 2T(2^\frac{m}{2}) + m\) <br>
            \(= 2S(m/2) + m\)<br><br>
            Proved that \(S(m) = O(mlogm)\) <br>
            \(T(n) = S(log_2n)\) <br>
            \(= O(log_2n*loglogn))
        </div>
    </div>
    <div>
        Master's Theorem
        <div>
            \(n \rightarrow\) a smaller problems of size n/6 fix up the solution with \(n^c\) <br>
            \(a \geq 1, b > 1, c \geq 0\), and \(T(n) = aT(n/b) + n^c\) <br>
            Then: <br>
            \(T(n) = \Theta(n^c) if c > log_ba\) <br>
                        \(\Theta(n^clogn) if c = log_ba\) <br>
                        \(Theta(n^{log_ba}) if c < log_ba\)
            <br><br>
            To prove the theorem, we only need to choos y > 0 s.t <br>
            \(\frac{a}{b^c}\gamma + 1 = \gamma\) <br>
            \(\gamma = \frac{1}{1-\frac{a}{b^c}} > 0\) <br>
            Proof of case I: <br>
            To prove \(T(n) \leq \gamman^c for \gamma > 0\) <br>
            \(T(n) = aT(n/b) + n^c\) <br>
            \(\leq a\gamma(n/b)^c + n^c\) <br>
            \(= (\frac{a}{b^c}\gamma + 1)n^c\) <br>
            \(= \gamma n^c\)
        </div>
    </div>
    <div>
        Counting inversion
        <div>
            1, 2, 3,..., n <br>
            \(i_1, i_2,..., i_n \leftarrow \) permutation <br>
            if j < k, and \(i_j > i_k\), then (j, k) is an inversion. 
        </div>
        <div>
            <em>Count the number of inversions in an array</em>
            <div class="definition">
                <i>Better</i>
                <div>Sort Count</div>
            </div>
            <div class="code">
                counter <- 0
                while (i < n/2 || j < n/2) {
                    if (A1[i] <= A2[j])
                        i++;
                    else
                        counter += n/2 - i + 1;
                        j++;
                }
            </div>
            <div class="divider"></div>
        </div>
        <div>
            <em>Find a max subarray</em>
            <div class="definition">
                <em>Trivial Case:</em>
                <div>Search every single subarray and sum them</div>
            </div>
            <div class="nospace b2">\(O(n^3)\)</div>
            <div class="definition">
                <em>Trivial 2:</em>
                <div></div>
            </div>
            <div class="nospace b2">\(O(n^2)\)</div>
            <div class="definition">
                <em>Better:</em>
                <div></div>
            </div>
            <div class="nospace b2">\(O(nlogn)\)</div>
            <div class="code">
                MS(A)
                    return max(MS(A1), MS(A2), maxSuffix(A1) + maxPrefix(A2))
            </div>
            <div>
                \(T(n) = 2T(n/2) + O(n)\) <br>
                \(= O(nlogn)\)
            </div>
            <div class="definition">
                <em>Even Better:</em>
                <div></div>
            </div>
            <div class="nospace b2">\(O(n)\)</div>
            <div class="divider"></div>
        </div>
    </div>
    <div>
        Big Integer Multiplication
        <div class="definition">
            <em>Trivial Solution:</em>
            <div></div>
        </div>
        <div class="nospace b2">\(O(n^2)\)</div>
        <div>
            \(m = n/2\) <br>
            \(x = 2^mx_1 + x_2\) <br>
            \(y = 2^my_1 + y_2\) <br>
            \(xy = 2^nx_1y_1 + 2^m(x_1y_2 + x_2y_1) + x_2y_2\) <br>
            <br>
            \(T(n) = 4T(n/2) + O(n)\) <br>
            a = 4 <br>
            b = 2 <br>
            c = 1 <br>
            \(c < log_ba\) <br>
            \(n^{log_ba} = n^2\)
        </div>
    </div>
</div>